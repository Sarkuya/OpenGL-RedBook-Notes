# Triangles in Detail#

**Project**: Chap_01/Triangles

**Description**: Draw two blue triangles in screen

## OpenGL Programming Concepts in Background ##

You are not dealing with a task as easy as driving or using a computer in OpenGL programming.
 Rather, you are making a car, or making a computer. It might frighen you, but it's not the fact.
 To help you achive such goals, OpenGL API has sent many professors to stand by your side.
 So, your mission is to understand what you are doing, get to know what tasks thses professors can do,
 and what tasks they can't do, and then issue right commands to them. Then your mission is accomplished. 

Since this is our first OpenGL application, before we touch the code, we get to have some OpenGL Programming
 concepts in background.

### About Client-Server Programming Mode ###

OpenGL is a client-server system, which has 2 meanings:

1. In a network, the client will issue OpenGL commands, while the server will render the image;
2. In the same computer, the client is the application you'are writing, while the server is OpenGL implemetation of the graphics hardware.

So, when we are writing an OpenGL application at most time in a single computer, we are actually making use of the functionality of the specific graphics card installed in our computer to render the images.

### About Rendering ###

A pixel is a smallest visual element in screen. No matter how the rendered image is complicated, it is composited of various of pixels. Each pixel has attributes such as position, color, etc.
 For each pixel, graphics card has corresponding memory to store its information. And when we put or modify the data in these memories, images on the screen will reflect immediately.
 These memories are called **framebuffer**.

However, we are **NOT** to find where these framebuffers are and manage the data in it. That's boring.
 We are doing a more easier job here. We specify vertices' position and color in client in some coordinate systems that we are familiar with, and it's the responsibility of OpenGL to map them in framebuffers.
 This is called **rasterization**.

### About VAOs and VBOs ###

In order to improve performence, some data in our application would nevertheless be copied to buffers. Again, it's easy since we care about only what to copy and **NOT** how to copy. 

In a client-server network, the client computer issues OpenGL commands to the server through the network.
 The client might issue lots of drawing command at the same time. If we send the vetex data each time we send drawing command,
 the netwok's inefficiency is obvious. 

OpenGL take such a approach - OpenGL server created vetex-buffer objects (**VBOs**) to allocate memory chunks to store the vetices data,
 tagged (or indexed) with the vetex array object (**VAO**) names. And each time the OpenGL application needs to render images using these vetices data, it does not actually
 transfer vertices data from the client, it just tell OpenGL server that it would like to use which VAO's buffer data by rebinding a specific
 VAO as the current VAO.

So, when receiving drawing commands from the client, OpenGL server fetches the vetices data previously saved from the buffer tagged with specific VAO name
 instead of from the client, and sends these data to the *framebuffer* immediately.

The same rule applies to non-network client-server mode. In this mode, the OpenGL server is the computer hosting the OpenGL
 program, and still it is the OpenGL server who manages the VAOs and VBOs.

### OpenGL Programs Basic Structure ###

That said, when we are coding in an OpenGL program, we usually do the following things:

1. In a setup-up routine:
    1. Create a VAO and bind it to current VAO.
    2. Supply with vetices data, and store them in VBO
2. In a displaying routine:
    1. rebind a VAO to current VAO.
    2. issue drawing command

We will deal with the first task in *init* function, and the second task in *display* function.

### About Shaders ###

OpenGL shaders are some programs compiled for and executed by the GPU (Graphics Processing Uint).

Graphics hardware has a small but very fast memory. To efficiently improve performence, some fundermental data,
 such as vertex position, vetex color, etc, can be stored in this memory area.

We need to supply these data to shaders in a specific way - a shading way.

## What We Do in *init* Routine ##

1. Generate and bind a vertex array.
2. Copy the data in vertex array to a buffer.
3. Complie shaders.
4. Tell the OpenGL how to use the data from data store of the buffer to feed the shader.



### Creating and Binding A Vertex Array Object (VAO) ###

    void glGenVertexArrays(	GLsizei n, GLuint *arrays);

Applied for new vertex array object names. OpenGL manages these names. Names are nothing but of type *GLuint* to identify the VAO that will be generated by the succeeding invocation of *glBindVertexArray*.

    void glBindVertexArray(GLuint array)

When parameter array is first bound, a new VAO will be created. And only at this binding point, the VAO's state and type are acquired.
 
### Creating and Populating Vetex-Buffer Object (VBO) ###

All data should be stored in buffer objects before drawing. Drawing means transfering the vertex data to OpenGL server.
 
    void glGenBuffers(GLsizei n, GLuint *buffers)
    void glBindBuffer(GLenum target, GLuint buffer)

We need to set up data in a VBO associated with current VAO. With parameter *target* specified with *GL_ARRAY_BUFFER*, *glBindBuffer* create a new VBO and set it as current VBO.

    void glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);

*glBufferData* populates current VBO with parameter *data*.

### Compiling and Linking with Shaders ###

We grouped all functions relating to shaders into a function *compileShaders*. In it, we call *loadShaders* to load two shader files (vs.glsl and fs.glsl), compile them, attach them
 to a shaper *program*, link the program, and use the program. Until then, these shaders has connection with the OpenGL application.

### Feeding data to Shaders ###

The communication between OpenGL applications and shaders behaves little bit like calling functions. 

## What We Do in *display* Routine ##



## Key Functions in Triangles Project ##

* *glBindVertexArray*
* *glBindBuffer* and *glBufferData*
* *glVertexAttribPointer*
* *glDrawArrays*





## References ##
1. OpenGL 4.5 Reference Pages: <https://www.opengl.org/sdk/docs/man/>